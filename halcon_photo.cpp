///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 20.05.0.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#    include <HALCON/HpThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#    include <HALCONxl/HpThread.h>
#  endif
#  include <stdio.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;

// Procedure declarations 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ();

// Procedures 
// Chapter: Develop
// Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
void dev_update_off ()
{

  //This procedure sets different update settings to 'off'.
  //This is useful to get the best performance and reduce overhead.
  //
  // dev_update_pc(...); only in hdevelop
  // dev_update_var(...); only in hdevelop
  // dev_update_window(...); only in hdevelop
  return;
}

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Image, ho_Region, ho_ROI_0, ho_RegionDilation;
  HObject  ho_ConnectedRegions, ho_SelectedRegions, ho_SortedRegions;
  HObject  ho_ObjectSelected, ho_Circle, ho_Contours, ho_Cross;

  // Local control variables
  HTuple  hv_WindowHandle, hv_WindowHandle1, hv_Files;
  HTuple  hv_distance, hv_Index1, hv_Number, hv_dis_region;
  HTuple  hv_angle_min_x, hv_angle_min_y, hv_Index, hv_DistanceMin;
  HTuple  hv_DistanceMax, hv_Row, hv_Column, hv_Num_cross;
  HTuple  hv_Angle, hv_Deg;

  //***********************************************显示设置**********************************
  dev_update_off();
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,1000,500,0,"visible","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,1000,500,0,"visible","",&hv_WindowHandle1);
  HDevWindowStack::Push(hv_WindowHandle1);
  //************************************************滤波****************************************
  ListFiles(//'E:/undergraduate/box/点云处理示例/image_data'
      "E:/undergraduate/box/\265\343\324\306\264\246\300\355\312\276\300\375/image_data", 
      "files", &hv_Files);
  hv_distance = HTuple();
  //Index1 := 80
  {
  HTuple end_val8 = (hv_Files.TupleLength())-1;
  HTuple step_val8 = 1;
  for (hv_Index1=0; hv_Index1.Continue(end_val8, step_val8); hv_Index1 += step_val8)
  {
    ReadImage(&ho_Image, HTuple(hv_Files[hv_Index1]));
    HDevWindowStack::SetActive(hv_WindowHandle);
    if (HDevWindowStack::IsOpen())
      DispObj(ho_Image, HDevWindowStack::GetActive());
    Threshold(ho_Image, &ho_Region, 128, 255);
    //设定感兴趣区域
    GenRectangle1(&ho_ROI_0, 0, 400, 500, 600);
    Intersection(ho_Region, ho_ROI_0, &ho_Region);
    //滤除杂点
    HDevWindowStack::SetActive(hv_WindowHandle1);
    DilationCircle(ho_Region, &ho_RegionDilation, 3.5);
    Connection(ho_RegionDilation, &ho_ConnectedRegions);
    SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", 75, 99999);
    //*************************************************计算距离与角度*********************************
    CountObj(ho_SelectedRegions, &hv_Number);
    SortRegion(ho_SelectedRegions, &ho_SortedRegions, "lower_left", "true", "row");
    hv_dis_region = HTuple();
    hv_angle_min_x = HTuple();
    hv_angle_min_y = HTuple();
    {
    HTuple end_val27 = hv_Number;
    HTuple step_val27 = 1;
    for (hv_Index=1; hv_Index.Continue(end_val27, step_val27); hv_Index += step_val27)
    {
      SelectObj(ho_SortedRegions, &ho_ObjectSelected, hv_Index);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_ObjectSelected, HDevWindowStack::GetActive());
      //得到距离雷达最短的距离
      DistancePr(ho_ObjectSelected, 500, 500, &hv_DistanceMin, &hv_DistanceMax);
      hv_dis_region[hv_Index-1] = hv_DistanceMin;
      GenCircleContourXld(&ho_Circle, 500, 500, hv_DistanceMin, 0, 6.28318, "positive", 
          1);
      GenContourRegionXld(ho_ObjectSelected, &ho_Contours, "center");
      IntersectionCircleContourXld(ho_Contours, 500, 500, hv_DistanceMin, 0, 6.28318, 
          "positive", &hv_Row, &hv_Column);
      GenCrossContourXld(&ho_Cross, hv_Row, hv_Column, 6, 0.785398);
      TupleLength(hv_Row, &hv_Num_cross);
      if (0 != (int(hv_Num_cross==0)))
      {
        continue;
      }
      //计算与水平线x轴的夹角
      AngleLx(500, 500, HTuple(hv_Row[0]), HTuple(hv_Column[0]), &hv_Angle);
      TupleDeg(hv_Angle, &hv_Deg);
      hv_angle_min_x[hv_Index-1] = hv_Deg;
      //计算与y轴正方向的夹角
      if (0 != (int(hv_Deg<=90)))
      {
        hv_angle_min_y[hv_Index-1] = 90-hv_Deg;
      }
      else
      {
        hv_angle_min_y[hv_Index-1] = -(hv_Deg-90);
      }
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Cross, HDevWindowStack::GetActive());
      if (HDevWindowStack::IsOpen())
        DispObj(ho_Circle, HDevWindowStack::GetActive());

    }
    }
    // stop(...); only in hdevelop
    if (HDevWindowStack::IsOpen())
      ClearWindow(HDevWindowStack::GetActive());
  }
  }






}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
HTuple      gStartMutex;
H_pthread_t gActionThread;
HBOOL       gTerminate = FALSE;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  UnlockMutex(gStartMutex);
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  LockMutex(gStartMutex);
  UnlockMutex(gStartMutex);

  try
  {
    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
  }

  // Tell the main thread to terminate itself.
  LockMutex(gStartMutex);
  gTerminate = TRUE;
  UnlockMutex(gStartMutex);
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  CreateMutex("type","sleep",&gStartMutex);
  LockMutex(gStartMutex);

  error = HpThreadHandleAlloc(&gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(gActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    HBOOL terminate;

    CFRunLoopRun();

    LockMutex(gStartMutex);
    terminate = gTerminate;
    UnlockMutex(gStartMutex);

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(gActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  ClearMutex(gStartMutex);
  return 0;
}
#endif

int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#endif

    // file was stored with local-8-bit encoding
    //   -> set the interface encoding accordingly
    SetHcppInterfaceStringEncodingIsUtf8(false);

    // Default settings used in HDevelop (can be omitted)
    SetSystem("width", 512);
    SetSystem("height", 512);

#ifndef __APPLE__
    action();
#else
    ret = apple_main(argc,argv);
#endif
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            (const char *)exception.ProcName(),
            (const char *)exception.ErrorMessage());
    ret = 1;
  }
  return ret;
}

#endif


#endif


